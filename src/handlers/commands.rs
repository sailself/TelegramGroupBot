use std::time::Duration;

use anyhow::Result;
use teloxide::prelude::*;
use teloxide::types::{
    InlineKeyboardButton, InlineKeyboardMarkup, InputFile, InputMedia, InputMediaPhoto,
    MessageEntityRef, MessageId, ParseMode,
};

use crate::config::{
    CONFIG, FACTCHECK_SYSTEM_PROMPT, PAINTME_SYSTEM_PROMPT, PORTRAIT_SYSTEM_PROMPT,
    PROFILEME_SYSTEM_PROMPT, TLDR_SYSTEM_PROMPT,
};
use crate::handlers::access::{check_access_control, is_rate_limited};
use crate::handlers::content::{
    create_telegraph_page, extract_telegraph_urls_and_content, extract_twitter_urls_and_content,
};
use crate::handlers::media::{collect_message_media, get_file_url, MediaCollectionOptions};
use crate::handlers::responses::send_response;
use crate::llm::media::detect_mime_type;
use crate::llm::{call_gemini, generate_image_with_gemini, generate_image_with_vertex, generate_video_with_veo};
use crate::state::{AppState, MediaGroupItem, PendingImageRequest};
use crate::tools::cwd_uploader::upload_image_bytes_to_cwd;
use crate::utils::timing::{complete_command_timer, start_command_timer};
use tracing::{error, warn};

const IMAGE_RESOLUTION_OPTIONS: [&str; 3] = ["2K", "4K", "1K"];
const IMAGE_ASPECT_RATIO_OPTIONS: [&str; 10] = [
    "4:3", "3:4", "16:9", "9:16", "1:1", "21:9", "3:2", "2:3", "5:4", "4:5",
];
const IMAGE_RESOLUTION_CALLBACK_PREFIX: &str = "image_res:";
const IMAGE_ASPECT_RATIO_CALLBACK_PREFIX: &str = "image_aspect:";
const IMAGE_DEFAULT_RESOLUTION: &str = "2K";
const IMAGE_DEFAULT_ASPECT_RATIO: &str = "4:3";
const IMAGE_CAPTION_LIMIT: usize = 1000;
const IMAGE_CAPTION_PROMPT_PREVIEW: usize = 900;

#[derive(Debug, Clone)]
struct ImageRequestContext {
    prompt: String,
    image_urls: Vec<String>,
    telegraph_contents: Vec<String>,
    original_message_text: String,
}

fn strip_command_prefix(text: &str, command_prefix: &str) -> String {
    if text.starts_with(command_prefix) {
        text[command_prefix.len()..].trim().to_string()
    } else {
        text.to_string()
    }
}

fn message_entities_for_text(message: &Message) -> Option<Vec<MessageEntityRef<'_>>> {
    if message.text().is_some() {
        message.parse_entities()
    } else {
        message.parse_caption_entities()
    }
}

fn escape_html(text: &str) -> String {
    let mut escaped = String::with_capacity(text.len());
    for ch in text.chars() {
        match ch {
            '&' => escaped.push_str("&amp;"),
            '<' => escaped.push_str("&lt;"),
            '>' => escaped.push_str("&gt;"),
            '"' => escaped.push_str("&quot;"),
            '\'' => escaped.push_str("&#39;"),
            _ => escaped.push(ch),
        }
    }
    escaped
}

fn truncate_chars(text: &str, max_chars: usize) -> (String, bool) {
    let mut iter = text.chars();
    let truncated: String = iter.by_ref().take(max_chars).collect();
    let was_truncated = iter.next().is_some();
    (truncated, was_truncated)
}

async fn build_image_caption(model_name: &str, prompt: &str) -> String {
    let safe_model = escape_html(model_name);
    let base_caption = format!("Generated by {}", safe_model);
    let clean_prompt = if prompt.trim().is_empty() {
        "No prompt provided."
    } else {
        prompt
    };
    let escaped_prompt = escape_html(clean_prompt);
    let mut caption = format!("{} with prompt:\n<pre>{}</pre>", base_caption, escaped_prompt);
    if caption.chars().count() <= IMAGE_CAPTION_LIMIT {
        return caption;
    }

    if let Some(url) = create_telegraph_page("Image Generation Prompt", clean_prompt).await {
        caption = format!(
            "{} with prompt:\n<a href=\"{}\">View it here</a>",
            base_caption,
            escape_html(&url)
        );
        if caption.chars().count() <= IMAGE_CAPTION_LIMIT {
            return caption;
        }
    }

    let (preview, was_truncated) = truncate_chars(clean_prompt, IMAGE_CAPTION_PROMPT_PREVIEW);
    let prompt_preview = if was_truncated {
        format!("{}...", preview)
    } else {
        preview
    };
    caption = format!(
        "{} with prompt:\n<pre>{}</pre>",
        base_caption,
        escape_html(&prompt_preview)
    );
    if caption.chars().count() <= IMAGE_CAPTION_LIMIT {
        caption
    } else {
        base_caption
    }
}

async fn prepare_image_request(
    bot: &Bot,
    state: &AppState,
    message: &Message,
    command_prefix: &str,
) -> Result<ImageRequestContext> {
    let original_message_text = message
        .text()
        .map(|value| value.to_string())
        .or_else(|| message.caption().map(|value| value.to_string()))
        .unwrap_or_default();

    let prompt_raw = strip_command_prefix(&original_message_text, command_prefix);
    let mut image_urls = Vec::new();
    let mut telegraph_texts = Vec::new();
    let prompt_entities = message_entities_for_text(message);

    if let Some(media_group_id) = message.media_group_id() {
        let group_items = state.media_groups.lock().get(media_group_id).cloned().unwrap_or_default();
        for item in group_items {
            if let Ok(url) = get_file_url(bot, &item.file_id).await {
                image_urls.push(url);
            }
        }
    }

    if let Some(photo_sizes) = message.photo() {
        if let Some(photo) = photo_sizes.last() {
            if let Ok(url) = get_file_url(bot, &photo.file.id).await {
                image_urls.push(url);
            }
        }
    }

    let (prompt, telegraph_contents) =
        extract_telegraph_urls_and_content(&prompt_raw, prompt_entities.as_deref(), 5).await;
    let (mut prompt, twitter_contents) =
        extract_twitter_urls_and_content(&prompt, prompt_entities.as_deref(), 5).await;
    telegraph_texts.extend(
        telegraph_contents
            .iter()
            .map(|content| content.text_content.clone()),
    );
    telegraph_texts.extend(
        twitter_contents
            .iter()
            .map(|content| content.text_content.clone()),
    );

    if let Some(reply) = message.reply_to_message() {
        if image_urls.is_empty() {
            if let Some(photo_sizes) = reply.photo() {
                if let Some(photo) = photo_sizes.last() {
                    if let Ok(url) = get_file_url(bot, &photo.file.id).await {
                        image_urls.push(url);
                    }
                }
            }
        }

        let reply_text = reply
            .text()
            .map(|value| value.to_string())
            .or_else(|| reply.caption().map(|value| value.to_string()))
            .unwrap_or_default();
        if !reply_text.trim().is_empty() {
            let reply_entities = message_entities_for_text(reply);
            let (reply_text, reply_telegraph) =
                extract_telegraph_urls_and_content(&reply_text, reply_entities.as_deref(), 5).await;
            let (reply_text, reply_twitter) =
                extract_twitter_urls_and_content(&reply_text, reply_entities.as_deref(), 5).await;
            telegraph_texts.extend(
                reply_telegraph
                    .iter()
                    .map(|content| content.text_content.clone()),
            );
            telegraph_texts.extend(
                reply_twitter
                    .iter()
                    .map(|content| content.text_content.clone()),
            );

            if prompt.trim().is_empty() {
                prompt = reply_text;
            } else if image_urls.is_empty() {
                prompt = format!("{}\n\n{}", reply_text, prompt);
            }
        }
    }

    Ok(ImageRequestContext {
        prompt,
        image_urls,
        telegraph_contents: telegraph_texts,
        original_message_text,
    })
}

fn build_resolution_keyboard(request_key: &str) -> InlineKeyboardMarkup {
    let buttons = IMAGE_RESOLUTION_OPTIONS
        .iter()
        .map(|res| {
            InlineKeyboardButton::callback(
                res.to_string(),
                format!("{}{}|{}", IMAGE_RESOLUTION_CALLBACK_PREFIX, request_key, res),
            )
        })
        .collect::<Vec<_>>();

    let rows = buttons
        .chunks(3)
        .map(|chunk| chunk.to_vec())
        .collect::<Vec<_>>();
    InlineKeyboardMarkup::new(rows)
}

fn build_aspect_ratio_keyboard(request_key: &str) -> InlineKeyboardMarkup {
    let buttons = IMAGE_ASPECT_RATIO_OPTIONS
        .iter()
        .map(|aspect| {
            InlineKeyboardButton::callback(
                aspect.to_string(),
                format!("{}{}|{}", IMAGE_ASPECT_RATIO_CALLBACK_PREFIX, request_key, aspect),
            )
        })
        .collect::<Vec<_>>();

    let rows = buttons
        .chunks(3)
        .map(|chunk| chunk.to_vec())
        .collect::<Vec<_>>();
    InlineKeyboardMarkup::new(rows)
}

async fn finalize_image_request(
    bot: &Bot,
    state: &AppState,
    request_key: &str,
    resolution: Option<&str>,
    aspect_ratio: Option<&str>,
) -> Result<()> {
    let request = state.pending_image_requests.lock().remove(request_key);
    let Some(request) = request else {
        return Ok(());
    };

    let final_resolution = resolution.unwrap_or(IMAGE_DEFAULT_RESOLUTION);
    let final_aspect = aspect_ratio.unwrap_or(IMAGE_DEFAULT_ASPECT_RATIO);

    let mut prompt = request.prompt.clone();
    if !request.telegraph_contents.is_empty() {
        prompt.push_str("\n\nAdditional context:\n");
        for content in &request.telegraph_contents {
            prompt.push_str(content);
            prompt.push('\n');
        }
    }
    if !final_resolution.is_empty() || !final_aspect.is_empty() {
        prompt.push_str(&format!("\n\nResolution: {}. Aspect ratio: {}.", final_resolution, final_aspect));
    }

    let processing_message_id = MessageId(request.selection_message_id as i32);
    let _ = bot
        .edit_message_text(
            ChatId(request.chat_id),
            processing_message_id,
            format!("Generating your image at {} resolution with {} aspect ratio...", final_resolution, final_aspect),
        )
        .await?;

    let images = if CONFIG.use_vertex_image {
        let model_hint = if CONFIG.vertex_image_model.trim().is_empty() {
            None
        } else {
            Some(CONFIG.vertex_image_model.as_str())
        };
        generate_image_with_vertex(&prompt, &request.image_urls, model_hint)
            .await
            .map_err(|err| anyhow::anyhow!(err.0))?
    } else {
        generate_image_with_gemini(&prompt, &request.image_urls, None, !CONFIG.cwd_pw_api_key.is_empty())
            .await
            .map_err(|err| anyhow::anyhow!(err.0))?
    };

    let model_name = if CONFIG.use_vertex_image && request.image_urls.is_empty() {
        if CONFIG.vertex_image_model.trim().is_empty() {
            "Vertex"
        } else {
            CONFIG.vertex_image_model.as_str()
        }
    } else {
        CONFIG.gemini_image_model.as_str()
    };
    let caption = build_image_caption(model_name, &prompt).await;

    let mut image_iter = images.into_iter();
    if let Some(first_image) = image_iter.next() {
        let media = InputMedia::Photo(
            InputMediaPhoto::new(InputFile::memory(first_image.clone()))
                .caption(caption.clone())
                .parse_mode(ParseMode::Html),
        );
        let edit_result = bot
            .edit_message_media(ChatId(request.chat_id), processing_message_id, media)
            .await;
        if edit_result.is_err() {
            bot.send_photo(ChatId(request.chat_id), InputFile::memory(first_image))
                .reply_to_message_id(MessageId(request.message_id as i32))
                .caption(caption)
                .parse_mode(ParseMode::Html)
                .await?;
        }
    }

    for image in image_iter {
        bot.send_photo(ChatId(request.chat_id), InputFile::memory(image))
            .reply_to_message_id(MessageId(request.message_id as i32))
            .await?;
    }

    Ok(())
}

pub async fn image_selection_callback(
    bot: Bot,
    state: AppState,
    query: CallbackQuery,
) -> Result<()> {
    let _ = bot.answer_callback_query(query.id.clone()).await;
    let Some(data) = &query.data else {
        return Ok(());
    };
    let query_user_id = i64::try_from(query.from.id.0).unwrap_or_default();

    if data.starts_with(IMAGE_RESOLUTION_CALLBACK_PREFIX) {
        let payload = data.trim_start_matches(IMAGE_RESOLUTION_CALLBACK_PREFIX);
        let mut parts = payload.split('|');
        let request_key = parts.next().unwrap_or("");
        let resolution = parts.next().unwrap_or("");
        if !IMAGE_RESOLUTION_OPTIONS.contains(&resolution) {
            return Ok(());
        }

        if let Some(request) = state.pending_image_requests.lock().get_mut(request_key) {
            if request.user_id != query_user_id {
                return Ok(());
            }
            request.resolution = Some(resolution.to_string());
        }

        if let Some(message) = &query.message {
            bot.edit_message_text(message.chat.id, message.id, format!("Resolution set to {}. Choose an aspect ratio (default: {}).", resolution, IMAGE_DEFAULT_ASPECT_RATIO))
                .reply_markup(build_aspect_ratio_keyboard(request_key))
                .await?;
        }
        return Ok(());
    }

    if data.starts_with(IMAGE_ASPECT_RATIO_CALLBACK_PREFIX) {
        let payload = data.trim_start_matches(IMAGE_ASPECT_RATIO_CALLBACK_PREFIX);
        let mut parts = payload.split('|');
        let request_key = parts.next().unwrap_or("");
        let aspect = parts.next().unwrap_or("");
        if !IMAGE_ASPECT_RATIO_OPTIONS.contains(&aspect) {
            return Ok(());
        }

        if let Some(request) = state.pending_image_requests.lock().get_mut(request_key) {
            if request.user_id != query_user_id {
                return Ok(());
            }
            request.aspect_ratio = Some(aspect.to_string());
        }

        finalize_image_request(&bot, &state, request_key, None, Some(aspect)).await?;
    }

    Ok(())
}

pub async fn img_handler(
    bot: Bot,
    state: AppState,
    message: Message,
    _prompt: Option<String>,
) -> Result<()> {
    if !check_access_control(&bot, &message, "img").await {
        return Ok(());
    }
    let user_id = message
        .from()
        .and_then(|user| i64::try_from(user.id.0).ok())
        .unwrap_or_default();
    if is_rate_limited(user_id) {
        bot.send_message(message.chat.id, "Rate limit exceeded. Please try again later.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let context = prepare_image_request(&bot, &state, &message, "/img").await?;
    if context.prompt.trim().is_empty() && context.image_urls.is_empty() {
        bot.send_message(message.chat.id, "Please provide a prompt or reply to an image.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let processing_message = bot
        .send_message(message.chat.id, "Generating your image...")
        .reply_to_message_id(message.id)
        .await?;

    let mut prompt_text = context.prompt.clone();
    if !context.telegraph_contents.is_empty() {
        prompt_text.push_str("\n\nAdditional context:\n");
        for content in &context.telegraph_contents {
            prompt_text.push_str(content);
            prompt_text.push('\n');
        }
    }

    let images = if CONFIG.use_vertex_image {
        let model_hint = if CONFIG.vertex_image_model.trim().is_empty() {
            None
        } else {
            Some(CONFIG.vertex_image_model.as_str())
        };
        generate_image_with_vertex(&prompt_text, &context.image_urls, model_hint)
            .await
            .map_err(|err| anyhow::anyhow!(err.0))?
    } else {
        generate_image_with_gemini(
            &prompt_text,
            &context.image_urls,
            None,
            !CONFIG.cwd_pw_api_key.is_empty(),
        )
        .await
        .map_err(|err| anyhow::anyhow!(err.0))?
    };

    let model_name = if CONFIG.use_vertex_image && context.image_urls.is_empty() {
        if CONFIG.vertex_image_model.trim().is_empty() {
            "Vertex"
        } else {
            CONFIG.vertex_image_model.as_str()
        }
    } else {
        CONFIG.gemini_image_model.as_str()
    };
    let caption = build_image_caption(model_name, &prompt_text).await;

    let mut image_iter = images.into_iter();
    if let Some(first_image) = image_iter.next() {
        let media = InputMedia::Photo(
            InputMediaPhoto::new(InputFile::memory(first_image.clone()))
                .caption(caption.clone())
                .parse_mode(ParseMode::Html),
        );
        let edit_result = bot
            .edit_message_media(message.chat.id, processing_message.id, media)
            .await;
        if edit_result.is_err() {
            bot.send_photo(message.chat.id, InputFile::memory(first_image))
                .reply_to_message_id(message.id)
                .caption(caption)
                .parse_mode(ParseMode::Html)
                .await?;
            let _ = bot
                .edit_message_text(message.chat.id, processing_message.id, "Generated image below.")
                .await;
        }
    }

    for image in image_iter {
        bot.send_photo(message.chat.id, InputFile::memory(image))
            .reply_to_message_id(message.id)
            .await?;
    }

    Ok(())
}

pub async fn image_handler(
    bot: Bot,
    state: AppState,
    message: Message,
    _prompt: Option<String>,
) -> Result<()> {
    if !check_access_control(&bot, &message, "image").await {
        return Ok(());
    }

    let user_id = message
        .from()
        .and_then(|user| i64::try_from(user.id.0).ok())
        .unwrap_or_default();
    if is_rate_limited(user_id) {
        bot.send_message(message.chat.id, "Rate limit exceeded. Please try again later.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let context = prepare_image_request(&bot, &state, &message, "/image").await?;
    if context.prompt.trim().is_empty() && context.image_urls.is_empty() {
        bot.send_message(message.chat.id, "Please provide a prompt or reply to an image.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let request_key = format!("{}_{}", message.chat.id.0, message.id.0);
    let selection_message = bot
        .send_message(message.chat.id, "Choose a resolution (default: 2K):")
        .reply_to_message_id(message.id)
        .reply_markup(build_resolution_keyboard(&request_key))
        .await?;
    let pending = PendingImageRequest {
        user_id,
        chat_id: message.chat.id.0,
        message_id: message.id.0 as i64,
        prompt: context.prompt,
        image_urls: context.image_urls,
        telegraph_contents: context.telegraph_contents,
        original_message_text: context.original_message_text,
        selection_message_id: selection_message.id.0 as i64,
        resolution: None,
        aspect_ratio: None,
    };

    state.pending_image_requests.lock().insert(request_key.clone(), pending);
    let bot_clone = bot.clone();
    let state_clone = state.clone();
    tokio::spawn(async move {
        tokio::time::sleep(Duration::from_secs(CONFIG.model_selection_timeout)).await;
        let request = state_clone.pending_image_requests.lock().get(&request_key).cloned();
        if let Some(request) = request {
            if request.resolution.is_none() {
                let _ = finalize_image_request(&bot_clone, &state_clone, &request_key, Some(IMAGE_DEFAULT_RESOLUTION), Some(IMAGE_DEFAULT_ASPECT_RATIO)).await;
            }
        }
    });

    Ok(())
}

pub async fn vid_handler(
    bot: Bot,
    message: Message,
    prompt: Option<String>,
) -> Result<()> {
    if !check_access_control(&bot, &message, "vid").await {
        return Ok(());
    }

    let user_id = message
        .from()
        .and_then(|user| i64::try_from(user.id.0).ok())
        .unwrap_or_default();
    if is_rate_limited(user_id) {
        bot.send_message(message.chat.id, "Rate limit exceeded. Please try again later.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let prompt_text = prompt.unwrap_or_else(|| {
        message
            .text()
            .map(|value| strip_command_prefix(value, "/vid"))
            .unwrap_or_default()
    });

    let processing_message = bot
        .send_message(message.chat.id, "Generating your video...")
        .reply_to_message_id(message.id)
        .await?;
    let (video_bytes, _mime_type) = generate_video_with_veo(&prompt_text, None).await?;

    if let Some(video_bytes) = video_bytes {
        let input = InputFile::memory(video_bytes).file_name("video.mp4");
        bot.send_video(message.chat.id, input).await?;
    } else {
        bot.edit_message_text(message.chat.id, processing_message.id, "Video generation is unavailable right now.").await?;
    }

    Ok(())
}

#[allow(deprecated)]
pub async fn tldr_handler(
    bot: Bot,
    state: AppState,
    message: Message,
    count: Option<String>,
) -> Result<()> {
    if !check_access_control(&bot, &message, "tldr").await {
        return Ok(());
    }

    let user_id = message
        .from()
        .and_then(|user| i64::try_from(user.id.0).ok())
        .unwrap_or_default();
    if is_rate_limited(user_id) {
        bot.send_message(message.chat.id, "Rate limit exceeded. Please try again later.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let mut timer = start_command_timer("tldr", &message);
    let processing_message = bot
        .send_message(message.chat.id, "Summarizing recent messages...")
        .reply_to_message_id(message.id)
        .await?;

    let messages = if let Some(reply) = message.reply_to_message() {
        state
            .db
            .select_messages_from_id(message.chat.id.0, reply.id.0 as i64)
            .await?
    } else {
        let n = count
            .as_ref()
            .and_then(|value| value.trim().parse::<i64>().ok())
            .unwrap_or(100);
        state.db.select_messages(message.chat.id.0, n).await?
    };

    if messages.is_empty() {
        bot.edit_message_text(
            message.chat.id,
            processing_message.id,
            "No messages found to summarize.",
        )
        .await?;
        complete_command_timer(&mut timer, "error", Some("no_messages".to_string()));
        return Ok(());
    }

    let mut chat_content = String::new();
    for msg in messages {
        let timestamp = msg.date.format("%Y-%m-%d %H:%M:%S");
        let username = msg.username.unwrap_or_else(|| "Anonymous".to_string());
        let text = msg.text.unwrap_or_default();
        chat_content.push_str(&format!("{} {}: {}\n", timestamp, username, text));
    }

    let system_prompt = TLDR_SYSTEM_PROMPT.replace("{bot_name}", "TelegramGroupHelperBot");
    let response = call_gemini(
        &system_prompt,
        &chat_content,
        Some("Chinese"),
        true,
        false,
        Some(&CONFIG.gemini_thinking_level),
        None,
        false,
        None,
        None,
        None,
        None,
    )
    .await?;

    if response.trim().is_empty() {
        bot.edit_message_text(
            processing_message.chat.id,
            processing_message.id,
            "Failed to generate a summary. Please try again later.",
        )
        .await?;
        complete_command_timer(&mut timer, "error", Some("empty_summary".to_string()));
        return Ok(());
    }

    let summary_text = response;
    let summary_with_model = format!("{}\n\n_Model: {}_", summary_text, CONFIG.gemini_model);

    let _ = bot
        .edit_message_text(
            processing_message.chat.id,
            processing_message.id,
            "Summary generated. Generating infographic...",
        )
        .await;

    let infographic_prompt = format!(
        "Create a clear infographic (no walls of text) summarizing the key points below. \
Use a 16:9 layout with readable labels and visual hierarchy suitable for Telegram.\
\n\n{}\n\nResolution: 4K. Aspect ratio: 16:9.",
        summary_text
    );

    let mut infographic_url = None;
    match generate_image_with_gemini(&infographic_prompt, &[], None, false).await {
        Ok(images) => {
            if let Some(image) = images.into_iter().next() {
                if CONFIG.cwd_pw_api_key.trim().is_empty() {
                    warn!("TLDR infographic generated but CWD_PW_API_KEY is not configured.");
                } else {
                    let mime_type =
                        detect_mime_type(&image).unwrap_or_else(|| "image/png".to_string());
                    infographic_url = upload_image_bytes_to_cwd(
                        &image,
                        &CONFIG.cwd_pw_api_key,
                        &mime_type,
                        Some(CONFIG.gemini_image_model.as_str()),
                        Some(&infographic_prompt),
                    )
                    .await;
                    if infographic_url.is_none() {
                        warn!("Failed to upload TLDR infographic to cwd.pw.");
                    }
                }
            } else {
                warn!("TLDR infographic generation returned no image.");
            }
        }
        Err(err) => {
            error!("Error generating TLDR infographic: {}", err);
        }
    }

    let mut telegraph_url = None;
    if let Some(url) = &infographic_url {
        let telegraph_content = format!(
            "![Infographic]({})\n\n{}\n\n_Model: {}_",
            url, summary_text, CONFIG.gemini_model
        );
        telegraph_url =
            create_telegraph_page("Message Summary with Infographic", &telegraph_content).await;
    }

    let final_message = if let Some(url) = telegraph_url {
        format!("Chat summary with infographic: [View it here]({})", url)
    } else if let Some(url) = infographic_url {
        format!("{}\n\nInfographic: {}", summary_with_model, url)
    } else {
        summary_with_model
    };

    let _ = bot
        .edit_message_text(
            processing_message.chat.id,
            processing_message.id,
            "Infographic step completed. Finalizing response...",
        )
        .await;

    send_response(
        &bot,
        processing_message.chat.id,
        processing_message.id,
        &final_message,
        "Message Summary",
        ParseMode::Markdown,
    )
    .await?;
    complete_command_timer(&mut timer, "success", None);

    Ok(())
}

#[allow(deprecated)]
pub async fn factcheck_handler(
    bot: Bot,
    state: AppState,
    message: Message,
    query: Option<String>,
) -> Result<()> {
    if !check_access_control(&bot, &message, "factcheck").await {
        return Ok(());
    }

    let user_id = message
        .from()
        .and_then(|user| i64::try_from(user.id.0).ok())
        .unwrap_or_default();
    if is_rate_limited(user_id) {
        bot.send_message(message.chat.id, "Rate limit exceeded. Please try again later.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let reply_message = message.reply_to_message();
    let mut query_text = query.unwrap_or_default();
    let query_entities = message_entities_for_text(&message);
    let mut telegraph_contents = Vec::new();
    let mut twitter_contents = Vec::new();

    let mut reply_text = String::new();
    if let Some(reply) = reply_message {
        reply_text = reply
            .text()
            .map(|value| value.to_string())
            .or_else(|| reply.caption().map(|value| value.to_string()))
            .unwrap_or_default();
        if !reply_text.trim().is_empty() {
            let reply_entities = message_entities_for_text(reply);
            let (reply_text_processed, reply_telegraph) =
                extract_telegraph_urls_and_content(&reply_text, reply_entities.as_deref(), 5).await;
            let (reply_text_processed, reply_twitter) =
                extract_twitter_urls_and_content(
                    &reply_text_processed,
                    reply_entities.as_deref(),
                    5,
                )
                .await;
            telegraph_contents.extend(reply_telegraph);
            twitter_contents.extend(reply_twitter);
            reply_text = reply_text_processed;
        }
    }

    if !query_text.trim().is_empty() {
        let (query_text_processed, query_telegraph) =
            extract_telegraph_urls_and_content(&query_text, query_entities.as_deref(), 5).await;
        let (query_text_processed, query_twitter) =
            extract_twitter_urls_and_content(&query_text_processed, query_entities.as_deref(), 5)
                .await;
        telegraph_contents.extend(query_telegraph);
        twitter_contents.extend(query_twitter);
        query_text = query_text_processed;
    }

    let statement = if query_text.trim().is_empty() {
        reply_text.clone()
    } else if reply_text.trim().is_empty() {
        query_text
    } else {
        format!(
            "Context from replied message: \"{}\"\n\nStatement: {}",
            reply_text, query_text
        )
    };

    if statement.trim().is_empty() {
        bot.send_message(message.chat.id, "Please reply to a message to fact-check.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }
    let statement = statement;

    let mut image_data_list = Vec::new();
    let mut video_data = None;
    let mut audio_data = None;

    if let Some(reply) = reply_message {
        let reply_media = collect_message_media(&bot, &state, reply, MediaCollectionOptions::for_commands()).await;
        image_data_list.extend(reply_media.images);
        video_data = reply_media.video;
        audio_data = reply_media.audio;
    }

    let (telegraph_images, telegraph_video, _telegraph_video_mime) =
        crate::handlers::content::download_telegraph_media(&telegraph_contents, 5, 1).await;
    image_data_list.extend(telegraph_images);
    if video_data.is_none() {
        video_data = telegraph_video;
    }

    let (twitter_images, twitter_video, _twitter_video_mime) =
        crate::handlers::content::download_twitter_media(&twitter_contents, 5, 1).await;
    image_data_list.extend(twitter_images);
    if video_data.is_none() {
        video_data = twitter_video;
    }

    let mut processing_message_text = if video_data.is_some() {
        "Analyzing video and fact-checking content...".to_string()
    } else if audio_data.is_some() {
        "Analyzing audio and fact-checking content...".to_string()
    } else if !image_data_list.is_empty() {
        format!(
            "Analyzing {} image(s) and fact-checking content...",
            image_data_list.len()
        )
    } else {
        "Fact-checking message...".to_string()
    };

    if !telegraph_contents.is_empty() {
        let image_count: usize = telegraph_contents
            .iter()
            .map(|content| content.image_urls.len())
            .sum();
        let video_count: usize = telegraph_contents
            .iter()
            .map(|content| content.video_urls.len())
            .sum();
        let mut media_info = String::new();
        if image_count > 0 {
            media_info.push_str(&format!(" with {} image(s)", image_count));
        }
        if video_count > 0 {
            if media_info.is_empty() {
                media_info.push_str(&format!(" with {} video(s)", video_count));
            } else {
                media_info.push_str(&format!(" and {} video(s)", video_count));
            }
        }

        if processing_message_text == "Fact-checking message..." {
            processing_message_text = format!(
                "Extracting and fact-checking content from {} Telegraph page(s){}...",
                telegraph_contents.len(),
                media_info
            );
        } else {
            let base = processing_message_text.trim_end_matches("...");
            processing_message_text = format!(
                "{} and {} Telegraph page(s){}...",
                base,
                telegraph_contents.len(),
                media_info
            );
        }
    }

    if !twitter_contents.is_empty() {
        let image_count: usize = twitter_contents
            .iter()
            .map(|content| content.image_urls.len())
            .sum();
        let video_count: usize = twitter_contents
            .iter()
            .map(|content| content.video_urls.len())
            .sum();
        let mut media_info = String::new();
        if image_count > 0 {
            media_info.push_str(&format!(" with {} image(s)", image_count));
        }
        if video_count > 0 {
            if media_info.is_empty() {
                media_info.push_str(&format!(" with {} video(s)", video_count));
            } else {
                media_info.push_str(&format!(" and {} video(s)", video_count));
            }
        }

        if processing_message_text == "Fact-checking message..." {
            processing_message_text = format!(
                "Extracting and fact-checking content from {} Twitter post(s){}...",
                twitter_contents.len(),
                media_info
            );
        } else {
            let base = processing_message_text.trim_end_matches("...");
            processing_message_text = format!(
                "{} and {} Twitter post(s){}...",
                base,
                twitter_contents.len(),
                media_info
            );
        }
    }

    let processing_message = bot
        .send_message(message.chat.id, processing_message_text)
        .reply_to_message_id(message.id)
        .await?;
    let now = chrono::Utc::now().format("%Y-%m-%d %H:%M:%S").to_string();
    let system_prompt = FACTCHECK_SYSTEM_PROMPT.replace("{current_datetime}", &now);
    let response = call_gemini(
        &system_prompt,
        &statement,
        None,
        true,
        false,
        Some(&CONFIG.gemini_thinking_level),
        None,
        !image_data_list.is_empty() || video_data.is_some() || audio_data.is_some(),
        Some(image_data_list),
        video_data,
        audio_data,
        None,
    )
    .await?;

    send_response(
        &bot,
        processing_message.chat.id,
        processing_message.id,
        &response,
        "Fact Check",
        ParseMode::Markdown,
    )
    .await?;

    Ok(())
}

#[allow(deprecated)]
pub async fn profileme_handler(
    bot: Bot,
    state: AppState,
    message: Message,
    style: Option<String>,
) -> Result<()> {
    if !check_access_control(&bot, &message, "profileme").await {
        return Ok(());
    }

    let user_id = message
        .from()
        .and_then(|user| i64::try_from(user.id.0).ok())
        .unwrap_or_default();
    if is_rate_limited(user_id) {
        bot.send_message(message.chat.id, "Rate limit exceeded. Please try again later.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let processing_message = bot
        .send_message(message.chat.id, "Generating your profile...")
        .reply_to_message_id(message.id)
        .await?;
    let history = state
        .db
        .select_messages_by_user(message.chat.id.0, user_id, CONFIG.user_history_message_count, true)
        .await?;

    if history.is_empty() {
        bot.edit_message_text(message.chat.id, processing_message.id, "I don't have enough of your messages in this chat yet.")
            .await?;
        return Ok(());
    }

    let mut formatted_history = String::from("Here is the user's recent chat history in this group:\n\n");
    for msg in history {
        let timestamp = msg.date.format("%Y-%m-%d %H:%M:%S");
        let text = msg.text.unwrap_or_default();
        formatted_history.push_str(&format!("{}: {}\n", timestamp, text));
    }

    let system_prompt = if let Some(style) = style.filter(|value| !value.trim().is_empty()) {
        format!(
            "{}\n\nStyle Instruction: {}",
            PROFILEME_SYSTEM_PROMPT,
            style.trim()
        )
    } else {
        format!(
            "{}\n\nStyle Instruction: Keep the profile professional, friendly and respectful.",
            PROFILEME_SYSTEM_PROMPT
        )
    };

    let response = call_gemini(
        &system_prompt,
        &formatted_history,
        None,
        false,
        false,
        Some(&CONFIG.gemini_thinking_level),
        None,
        false,
        None,
        None,
        None,
        None,
    )
    .await?;

    send_response(
        &bot,
        processing_message.chat.id,
        processing_message.id,
        &response,
        "Your User Profile",
        ParseMode::Markdown,
    )
    .await?;

    Ok(())
}

pub async fn paintme_handler(
    bot: Bot,
    state: AppState,
    message: Message,
    portrait: bool,
) -> Result<()> {
    if !check_access_control(&bot, &message, "paintme").await {
        return Ok(());
    }

    let user_id = message
        .from()
        .and_then(|user| i64::try_from(user.id.0).ok())
        .unwrap_or_default();
    if is_rate_limited(user_id) {
        bot.send_message(message.chat.id, "Rate limit exceeded. Please try again later.")
            .reply_to_message_id(message.id)
            .await?;
        return Ok(());
    }

    let processing_message = bot
        .send_message(message.chat.id, "Creating your image prompt...")
        .reply_to_message_id(message.id)
        .await?;
    let history = state
        .db
        .select_messages_by_user(message.chat.id.0, user_id, CONFIG.user_history_message_count, true)
        .await?;

    if history.is_empty() {
        bot.edit_message_text(message.chat.id, processing_message.id, "I don't have enough of your messages in this chat yet.")
            .await?;
        return Ok(());
    }

    let mut formatted_history = String::from("Here is the user's recent chat history in this group:\n\n");
    for msg in history {
        let timestamp = msg.date.format("%Y-%m-%d %H:%M:%S");
        let text = msg.text.unwrap_or_default();
        formatted_history.push_str(&format!("{}: {}\n", timestamp, text));
    }

    let prompt_system = if portrait {
        PORTRAIT_SYSTEM_PROMPT
    } else {
        PAINTME_SYSTEM_PROMPT
    };

    let prompt = call_gemini(
        prompt_system,
        &formatted_history,
        None,
        false,
        false,
        Some(&CONFIG.gemini_thinking_level),
        None,
        false,
        None,
        None,
        None,
        None,
    )
    .await?;

    let status_text = if portrait {
        "Generating your portrait..."
    } else {
        "Generating your image..."
    };
    let _ = bot
        .edit_message_text(message.chat.id, processing_message.id, status_text)
        .await;

    let images = if CONFIG.use_vertex_image {
        let model_hint = if CONFIG.vertex_image_model.trim().is_empty() {
            None
        } else {
            Some(CONFIG.vertex_image_model.as_str())
        };
        generate_image_with_vertex(&prompt, &[], model_hint)
            .await
            .map_err(|err| anyhow::anyhow!(err.0))?
    } else {
        generate_image_with_gemini(&prompt, &[], None, !CONFIG.cwd_pw_api_key.is_empty())
            .await
            .map_err(|err| anyhow::anyhow!(err.0))?
    };

    let model_name = if CONFIG.use_vertex_image {
        if CONFIG.vertex_image_model.trim().is_empty() {
            "Vertex"
        } else {
            CONFIG.vertex_image_model.as_str()
        }
    } else {
        CONFIG.gemini_image_model.as_str()
    };
    let caption = build_image_caption(model_name, &prompt).await;

    let mut image_iter = images.into_iter();
    if let Some(first_image) = image_iter.next() {
        let media = InputMedia::Photo(
            InputMediaPhoto::new(InputFile::memory(first_image.clone()))
                .caption(caption.clone())
                .parse_mode(ParseMode::Html),
        );
        let edit_result = bot
            .edit_message_media(message.chat.id, processing_message.id, media)
            .await;
        if edit_result.is_err() {
            bot.send_photo(message.chat.id, InputFile::memory(first_image))
                .reply_to_message_id(message.id)
                .caption(caption)
                .parse_mode(ParseMode::Html)
                .await?;
            let _ = bot
                .edit_message_text(message.chat.id, processing_message.id, "Generated image below.")
                .await;
        }
    }

    for image in image_iter {
        bot.send_photo(message.chat.id, InputFile::memory(image))
            .reply_to_message_id(message.id)
            .await?;
    }

    Ok(())
}

#[allow(deprecated)]
pub async fn help_handler(bot: Bot, message: Message) -> Result<()> {
    if !check_access_control(&bot, &message, "help").await {
        return Ok(());
    }

    let help_text = "
*TelegramGroupHelperBot Commands*

/tldr - Summarize previous messages in the chat
Usage: Reply to a message with `/tldr` to summarize all messages between that message and the present.

/factcheck - Fact-check a statement or text
Usage: `/factcheck [statement]` or reply to a message with `/factcheck`

/q - Ask a question
Usage: `/q [your question]`

/qq - Quick Gemini answer using the default Gemini model
Usage: `/qq [your quick question]`

/img - Generate or edit an image using Gemini
Usage: `/img [description]` for generating a new image
Or reply to an image with `/img [description]` to edit that image

/image - Generate or edit an image with resolution and aspect ratio choices
Usage: `/image [description]` and pick resolution (2K/4K/1K) and aspect ratio

/vid - Generate a video
Usage: `/vid [text prompt]` (optionally reply to an image)
Or: `/vid` (replying to an image with an optional text prompt in the caption or command)

/profileme - Generate your user profile based on your chat history in this group.
Usage: `/profileme`
Or: `/profileme [Language style of the profile]`

/paintme - Generate an image representing you based on your chat history in this group.
Usage: `/paintme`

/portraitme - Generate a portrait of you based on your chat history in this group.
Usage: `/portraitme`

/support - Show support information and Ko-fi link
Usage: `/support`

/help - Show this help message
";

    bot.send_message(message.chat.id, help_text)
        .reply_to_message_id(message.id)
        .parse_mode(ParseMode::Markdown)
        .await?;
    Ok(())
}

#[allow(deprecated)]
pub async fn support_handler(bot: Bot, message: Message) -> Result<()> {
    if !check_access_control(&bot, &message, "support").await {
        return Ok(());
    }

    let support_url = match reqwest::Url::parse(CONFIG.support_link.trim()) {
        Ok(url) => url,
        Err(_) => {
            bot.send_message(message.chat.id, CONFIG.support_message.clone())
                .reply_to_message_id(message.id)
                .parse_mode(ParseMode::Markdown)
                .await?;
            return Ok(());
        }
    };

    let keyboard = InlineKeyboardMarkup::new(vec![vec![InlineKeyboardButton::url(
        "Support the bot",
        support_url,
    )]]);

    bot.send_message(message.chat.id, CONFIG.support_message.clone())
        .reply_to_message_id(message.id)
        .reply_markup(keyboard)
        .parse_mode(ParseMode::Markdown)
        .await?;
    Ok(())
}

pub async fn start_handler(bot: Bot, message: Message) -> Result<()> {
    bot.send_message(message.chat.id, "Hello! I am TelegramGroupHelperBot. Use /help to see commands.")
        .reply_to_message_id(message.id)
        .await?;
    Ok(())
}

pub async fn handle_media_group(state: AppState, message: Message) {
    if let Some(media_group_id) = message.media_group_id() {
        if let Some(photo_sizes) = message.photo() {
            if let Some(photo) = photo_sizes.last() {
                let mut groups = state.media_groups.lock();
                let entry = groups.entry(media_group_id.to_string()).or_default();
                entry.push(MediaGroupItem {
                    file_id: photo.file.id.clone(),
                });
            }
        }
    }
}
